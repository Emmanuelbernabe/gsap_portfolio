{
  "version": 3,
  "sources": ["../../gsap/ScrollSmoother.js"],
  "sourcesContent": ["function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*!\n * ScrollSmoother 3.10.4\n * https://greensock.com\n *\n * @license Copyright 2008-2022, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nvar gsap,\n    _coreInitted,\n    _win,\n    _doc,\n    _docEl,\n    _body,\n    _root,\n    _toArray,\n    _clamp,\n    ScrollTrigger,\n    _mainInstance,\n    _expo,\n    _getVelocityProp,\n    _inputObserver,\n    _windowExists = function _windowExists() {\n  return typeof window !== \"undefined\";\n},\n    _getGSAP = function _getGSAP() {\n  return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n},\n    _bonusValidated = 1,\n    //<name>ScrollSmoother</name>\n_isViewport = function _isViewport(e) {\n  return !!~_root.indexOf(e);\n},\n    _getTime = Date.now,\n    _round = function _round(value) {\n  return Math.round(value * 100000) / 100000 || 0;\n},\n    _autoDistance = function _autoDistance(el, progress) {\n  // for calculating the distance (and offset) for elements with speed: \"auto\". Progress is for if it's \"above the fold\" (negative start position), so we can crop as little as possible.\n  var parent = el.parentNode || _docEl,\n      b1 = el.getBoundingClientRect(),\n      b2 = parent.getBoundingClientRect(),\n      gapTop = b2.top - b1.top,\n      gapBottom = b2.bottom - b1.bottom,\n      change = (Math.abs(gapTop) > Math.abs(gapBottom) ? gapTop : gapBottom) / (1 - progress),\n      offset = -change * progress,\n      ratio,\n      extraChange;\n\n  if (change > 0) {\n    // if the image starts at the BOTTOM of the container, adjust things so that it shows as much of the image as possible while still covering.\n    ratio = b2.height / (_win.innerHeight + b2.height);\n    extraChange = ratio === 0.5 ? b2.height * 2 : Math.min(b2.height, -change * ratio / (2 * ratio - 1)) * 2;\n    offset += -extraChange / 2; // whatever the offset, we must double that in the opposite direction to compensate.\n\n    change += extraChange;\n  }\n\n  return {\n    change: change,\n    offset: offset\n  };\n},\n    _wrap = function _wrap(el) {\n  var wrapper = _doc.querySelector(\".ScrollSmoother-wrapper\"); // some frameworks load multiple times, so one already exists, just use that to avoid duplicates\n\n\n  if (!wrapper) {\n    wrapper = _doc.createElement(\"div\");\n    wrapper.classList.add(\"ScrollSmoother-wrapper\");\n    el.parentNode.insertBefore(wrapper, el);\n    wrapper.appendChild(el);\n  }\n\n  return wrapper;\n};\n\nexport var ScrollSmoother = /*#__PURE__*/function () {\n  function ScrollSmoother(vars) {\n    var _this = this;\n\n    _coreInitted || ScrollSmoother.register(gsap) || console.warn(\"Please gsap.registerPlugin(ScrollSmoother)\");\n    vars = this.vars = vars || {};\n    _mainInstance && _mainInstance.kill();\n    _mainInstance = this;\n\n    var _vars = vars,\n        smoothTouch = _vars.smoothTouch,\n        _onUpdate = _vars.onUpdate,\n        onStop = _vars.onStop,\n        smooth = _vars.smooth,\n        onFocusIn = _vars.onFocusIn,\n        normalizeScroll = _vars.normalizeScroll,\n        content,\n        wrapper,\n        height,\n        mainST,\n        effects,\n        sections,\n        intervalID,\n        wrapperCSS,\n        contentCSS,\n        paused,\n        pausedNormalizer,\n        recordedRefreshScroll,\n        scrollFunc = ScrollTrigger.getScrollFunc(_win),\n        smoothDuration = ScrollTrigger.isTouch === 1 ? smoothTouch === true ? 0.8 : parseFloat(smoothTouch) || 0 : smooth === 0 || smooth === false ? 0 : parseFloat(smooth) || 0.8,\n        currentY = 0,\n        delta = 0,\n        startupPhase = 1,\n        tracker = _getVelocityProp(0),\n        updateVelocity = function updateVelocity() {\n      return tracker.update(-currentY);\n    },\n        scroll = {\n      y: 0\n    },\n        removeScroll = function removeScroll() {\n      return content.style.overflow = \"visible\";\n    },\n        isProxyScrolling,\n        killScrub = function killScrub(trigger) {\n      trigger.update(); // it's possible that it hasn't been synchronized with the actual scroll position yet, like if it's later in the _triggers Array. If it was already updated, it'll skip the processing anyway.\n\n      var scrub = trigger.getTween();\n\n      if (scrub) {\n        scrub.pause();\n        scrub._time = scrub._dur; // force the playhead to completion without rendering just so that when it resumes, it doesn't jump back in the .resetTo().\n\n        scrub._tTime = scrub._tDur;\n      }\n\n      isProxyScrolling = false;\n      trigger.animation.progress(trigger.progress, true);\n    },\n        render = function render(y, force) {\n      if (y !== currentY && !paused || force) {\n        smoothDuration && (content.style.transform = \"matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, \" + y + \", 0, 1)\"); //smoothDuration && (content.style.transform = \"translateY(\" + y + \"px)\"); // NOTE: when we used matrix3d() or set will-change: transform, it performed noticeably worse on iOS counter-intuitively!\n\n        delta = y - currentY;\n        currentY = y;\n        ScrollTrigger.isUpdating || ScrollTrigger.update();\n      }\n    },\n        scrollTop = function scrollTop(value) {\n      if (arguments.length) {\n        paused ? currentY = -value : render(-value);\n        scroll.y = -value; // don't use currentY because we must accurately track the delta variable (in render() method)\n\n        isProxyScrolling = true; // otherwise, if snapping was applied (or anything that attempted to SET the scroll proxy's scroll position), we'd set the scroll here which would then (on the next tick) update the content tween/ScrollTrigger which would try to smoothly animate to that new value, thus the scrub tween would impede the progress. So we use this flag to respond accordingly in the ScrollTrigger's onUpdate and effectively force the scrub to its end immediately.\n\n        scrollFunc(value);\n        return this;\n      }\n\n      return -currentY - scrollFunc.offset;\n    },\n        lastFocusElement,\n        _onFocusIn = function _onFocusIn(e) {\n      // when the focus changes, make sure that element is on-screen\n      wrapper.scrollTop = 0;\n\n      if (onFocusIn && onFocusIn(_this, e) === false) {\n        return;\n      }\n\n      ScrollTrigger.isInViewport(e.target) || e.target === lastFocusElement || _this.scrollTo(e.target, false, \"center center\");\n      lastFocusElement = e.target;\n    },\n        adjustParallaxPosition = function adjustParallaxPosition(triggers, createdAfterEffectWasApplied) {\n      var pins, start, dif, markers;\n      effects.forEach(function (st) {\n        pins = st.pins;\n        markers = st.markers;\n        triggers.forEach(function (trig) {\n          if ((trig.trigger === st.trigger || trig.pinnedContainer === st.trigger) && st !== trig) {\n            start = trig.start;\n            dif = (start - st.start - st.offset) / st.ratio - (start - st.start); // createdAfterEffectWasApplied && (dif -= (gsap.getProperty(st.trigger, \"y\") - st.startY) / st.ratio); // the effect applied a y offset, so if the ScrollTrigger was created after that, it'll be based on that position so we must compensate. Later we added code to ScrollTrigger to roll back in this situation anyway, so this isn't necessary. Saving it in case a situation arises where it comes in handy.\n\n            pins.forEach(function (p) {\n              return dif -= p.distance / st.ratio - p.distance;\n            });\n            trig.setPositions(start + dif, trig.end + dif);\n            trig.markerStart && markers.push(gsap.quickSetter([trig.markerStart, trig.markerEnd], \"y\", \"px\"));\n\n            if (trig.pin && trig.end > 0) {\n              dif = trig.end - trig.start;\n              pins.push({\n                start: trig.start,\n                end: trig.end,\n                distance: dif,\n                trig: trig\n              });\n              st.setPositions(st.start, st.end + dif);\n              st.vars.onRefresh(st);\n            }\n          }\n        });\n      });\n    },\n        onRefresh = function onRefresh() {\n      removeScroll();\n      requestAnimationFrame(removeScroll);\n\n      if (effects) {\n        // adjust all the effect start/end positions including any pins!\n        effects.forEach(function (st) {\n          var start = st.start,\n              end = st.auto ? Math.min(ScrollTrigger.maxScroll(st.scroller), st.end) : start + (st.end - start) / st.ratio,\n              offset = (end - st.end) / 2; // we split the difference so that it reaches its natural position in the MIDDLE of the viewport\n\n          start -= offset;\n          end -= offset;\n          st.offset = offset || 0.0001; // we assign at least a tiny value because we check in the onUpdate for .offset being set in order to apply values.\n\n          st.pins.length = 0;\n          st.setPositions(Math.min(start, end), Math.max(start, end));\n          st.vars.onRefresh(st);\n        });\n        adjustParallaxPosition(ScrollTrigger.sort());\n      }\n\n      tracker.reset();\n    },\n        restoreEffects = function restoreEffects() {\n      return effects && effects.forEach(function (st) {\n        return st.vars.onRefresh(st);\n      });\n    },\n        revertEffects = function revertEffects() {\n      effects && effects.forEach(function (st) {\n        return st.vars.onRefreshInit(st);\n      });\n      return restoreEffects;\n    },\n        effectValueGetter = function effectValueGetter(name, value, index, el) {\n      return function () {\n        var v = typeof value === \"function\" ? value(index, el) : value;\n        v || v === 0 || (v = el.getAttribute(\"data-\" + name) || (name === \"speed\" ? 1 : 0));\n        el.setAttribute(\"data-\" + name, v);\n        return v === \"auto\" ? v : parseFloat(v);\n      };\n    },\n        createEffect = function createEffect(el, speed, lag, index) {\n      var getSpeed = effectValueGetter(\"speed\", speed, index, el),\n          getLag = effectValueGetter(\"lag\", lag, index, el),\n          startY = gsap.getProperty(el, \"y\"),\n          cache = el._gsap,\n          ratio,\n          st,\n          autoSpeed,\n          scrub,\n          progressOffset,\n          yOffset,\n          initDynamicValues = function initDynamicValues() {\n        speed = getSpeed();\n        lag = getLag();\n        ratio = parseFloat(speed) || 1;\n        autoSpeed = speed === \"auto\";\n        progressOffset = autoSpeed ? 0 : 0.5;\n        scrub && scrub.kill();\n        scrub = lag && gsap.to(el, {\n          ease: _expo,\n          overwrite: false,\n          y: \"+=0\",\n          duration: lag\n        });\n\n        if (st) {\n          st.ratio = ratio;\n          st.autoSpeed = autoSpeed;\n        }\n      },\n          revert = function revert() {\n        cache.y = startY + \"px\";\n        cache.renderTransform(1);\n        initDynamicValues();\n      },\n          pins = [],\n          markers = [],\n          change = 0,\n          updateChange = function updateChange(self) {\n        if (autoSpeed) {\n          revert();\n\n          var auto = _autoDistance(el, _clamp(0, 1, -self.start / (self.end - self.start)));\n\n          change = auto.change;\n          yOffset = auto.offset;\n        } else {\n          change = (self.end - self.start) * (1 - ratio);\n          yOffset = 0;\n        }\n\n        pins.forEach(function (p) {\n          return change -= p.distance * (1 - ratio);\n        });\n        self.vars.onUpdate(self);\n        scrub && scrub.progress(1);\n      };\n\n      initDynamicValues();\n\n      if (ratio !== 1 || autoSpeed || scrub) {\n        st = ScrollTrigger.create({\n          trigger: autoSpeed ? el.parentNode : el,\n          scroller: wrapper,\n          scrub: true,\n          refreshPriority: -999,\n          // must update AFTER any other ScrollTrigger pins\n          onRefreshInit: revert,\n          onRefresh: updateChange,\n          onKill: function onKill(self) {\n            var i = effects.indexOf(self);\n            i >= 0 && effects.splice(i, 1);\n            revert();\n          },\n          onUpdate: function onUpdate(self) {\n            var y = startY + change * (self.progress - progressOffset),\n                i = pins.length,\n                extraY = 0,\n                pin,\n                scrollY,\n                end;\n\n            if (self.offset) {\n              // wait until the effects are adjusted.\n              if (i) {\n                // pinning must be handled in a special way because when pinned, slope changes to 1.\n                scrollY = -currentY; // -scroll.y;\n\n                end = self.end;\n\n                while (i--) {\n                  pin = pins[i];\n\n                  if (pin.trig.isActive || scrollY >= pin.start && scrollY <= pin.end) {\n                    // currently pinned so no need to set anything\n                    if (scrub) {\n                      pin.trig.progress += pin.trig.direction < 0 ? 0.001 : -0.001; // just to make absolutely sure that it renders (if the progress didn't change, it'll skip)\n\n                      pin.trig.update(0, 0, 1);\n                      scrub.resetTo(\"y\", parseFloat(cache.y), -delta, true);\n                      startupPhase && scrub.progress(1);\n                    }\n\n                    return;\n                  }\n\n                  scrollY > pin.end && (extraY += pin.distance);\n                  end -= pin.distance;\n                }\n\n                y = startY + extraY + change * ((gsap.utils.clamp(self.start, self.end, scrollY) - self.start - extraY) / (end - self.start) - progressOffset);\n              }\n\n              y = _round(y + yOffset);\n              markers.length && !autoSpeed && markers.forEach(function (setter) {\n                return setter(y - extraY);\n              });\n\n              if (scrub) {\n                scrub.resetTo(\"y\", y, -delta, true);\n                startupPhase && scrub.progress(1);\n              } else {\n                cache.y = y + \"px\";\n                cache.renderTransform(1);\n              }\n            }\n          }\n        });\n        updateChange(st);\n        gsap.core.getCache(st.trigger).stRevert = revertEffects; // if user calls ScrollSmoother.create() with effects and THEN creates a ScrollTrigger on the same trigger element, the effect would throw off the start/end positions thus we needed a way to revert things when creating a new ScrollTrigger in that scenario, so we use this stRevert property of the GSCache inside ScrollTrigger.\n\n        st.startY = startY;\n        st.pins = pins;\n        st.markers = markers;\n        st.ratio = ratio;\n        st.autoSpeed = autoSpeed;\n        el.style.willChange = \"transform\";\n      }\n\n      return st;\n    };\n\n    ScrollTrigger.addEventListener(\"refresh\", onRefresh);\n    gsap.delayedCall(0.5, function () {\n      return startupPhase = 0;\n    });\n    this.scrollTop = scrollTop;\n\n    this.scrollTo = function (target, smooth, position) {\n      var p = gsap.utils.clamp(0, ScrollTrigger.maxScroll(_win), isNaN(target) ? _this.offset(target, position) : +target);\n      !smooth ? scrollTop(p) : paused ? gsap.to(_this, {\n        duration: smoothDuration,\n        scrollTop: p,\n        overwrite: \"auto\",\n        ease: _expo\n      }) : scrollFunc(p);\n    };\n\n    this.offset = function (target, position) {\n      target = _toArray(target)[0];\n      var cssText = target.style.cssText,\n          // because if there's an effect applied, we revert(). We need to restore.\n      st = ScrollTrigger.create({\n        trigger: target,\n        start: position || \"top top\"\n      }),\n          y;\n      effects && adjustParallaxPosition([st], true);\n      y = st.start;\n      st.kill(false);\n      target.style.cssText = cssText;\n      gsap.core.getCache(target).uncache = 1;\n      return y;\n    };\n\n    function refreshHeight() {\n      height = content.clientHeight;\n      content.style.overflow = \"visible\";\n      _body.style.height = height + \"px\";\n      return height - _win.innerHeight;\n    }\n\n    this.content = function (element) {\n      if (arguments.length) {\n        var newContent = _toArray(element || \"#smooth-content\")[0] || _body.children[0];\n\n        if (newContent !== content) {\n          content = newContent;\n          contentCSS = content.getAttribute(\"style\") || \"\";\n          gsap.set(content, {\n            overflow: \"visible\",\n            width: \"100%\",\n            boxSizing: \"border-box\"\n          });\n        }\n\n        return this;\n      }\n\n      return content;\n    };\n\n    this.wrapper = function (element) {\n      if (arguments.length) {\n        wrapper = _toArray(element || \"#smooth-wrapper\")[0] || _wrap(content);\n        wrapperCSS = wrapper.getAttribute(\"style\") || \"\";\n        refreshHeight();\n        gsap.set(wrapper, smoothDuration ? {\n          overflow: \"hidden\",\n          position: \"fixed\",\n          height: \"100%\",\n          width: \"100%\",\n          top: 0,\n          left: 0,\n          right: 0,\n          bottom: 0\n        } : {\n          overflow: \"visible\",\n          position: \"relative\",\n          width: \"100%\",\n          height: \"auto\",\n          top: \"auto\",\n          bottom: \"auto\",\n          left: \"auto\",\n          right: \"auto\"\n        });\n        return this;\n      }\n\n      return wrapper;\n    };\n\n    this.effects = function (targets, config) {\n      var _effects;\n\n      effects || (effects = []);\n\n      if (!targets) {\n        return effects.slice(0);\n      }\n\n      targets = _toArray(targets);\n      targets.forEach(function (target) {\n        var i = effects.length;\n\n        while (i--) {\n          if (effects[i].trigger === target) {\n            effects[i].kill();\n            effects.splice(i, 1);\n          }\n        }\n      });\n      config = config || {};\n      var _config = config,\n          speed = _config.speed,\n          lag = _config.lag,\n          effectsToAdd = [],\n          i,\n          st;\n\n      for (i = 0; i < targets.length; i++) {\n        st = createEffect(targets[i], speed, lag, i);\n        st && effectsToAdd.push(st);\n      }\n\n      (_effects = effects).push.apply(_effects, effectsToAdd);\n\n      return effectsToAdd;\n    };\n\n    this.sections = function (targets, config) {\n      var _sections;\n\n      sections || (sections = []);\n\n      if (!targets) {\n        return sections.slice(0);\n      }\n\n      var newSections = _toArray(targets).map(function (el) {\n        return ScrollTrigger.create({\n          trigger: el,\n          start: \"top 120%\",\n          end: \"bottom -20%\",\n          onToggle: function onToggle(self) {\n            el.style.opacity = self.isActive ? \"1\" : \"0\";\n            el.style.pointerEvents = self.isActive ? \"all\" : \"none\";\n          }\n        });\n      });\n\n      config && config.add ? (_sections = sections).push.apply(_sections, newSections) : sections = newSections.slice(0);\n      return newSections;\n    };\n\n    this.content(vars.content);\n    this.wrapper(vars.wrapper);\n\n    this.render = function (y) {\n      return render(y || y === 0 ? y : currentY);\n    };\n\n    this.getVelocity = function () {\n      return tracker.getVelocity(-currentY);\n    };\n\n    ScrollTrigger.scrollerProxy(wrapper, {\n      scrollTop: scrollTop,\n      scrollHeight: function scrollHeight() {\n        return refreshHeight() && _body.scrollHeight;\n      },\n      fixedMarkers: vars.fixedMarkers !== false && !!smoothDuration,\n      content: content,\n      getBoundingClientRect: function getBoundingClientRect() {\n        return {\n          top: 0,\n          left: 0,\n          width: _win.innerWidth,\n          height: _win.innerHeight\n        };\n      }\n    });\n    ScrollTrigger.defaults({\n      scroller: wrapper\n    });\n    var existingScrollTriggers = ScrollTrigger.getAll().filter(function (st) {\n      return st.scroller === _win || st.scroller === wrapper;\n    });\n    existingScrollTriggers.forEach(function (st) {\n      return st.revert(true);\n    }); // in case it's in an environment like React where child components that have ScrollTriggers instantiate BEFORE the parent that does ScrollSmoother.create(...);\n\n    mainST = ScrollTrigger.create({\n      animation: gsap.to(scroll, {\n        y: function y() {\n          return -refreshHeight();\n        },\n        ease: \"none\",\n        data: \"ScrollSmoother\",\n        duration: 100,\n        // for added precision\n        onUpdate: function onUpdate() {\n          var force = isProxyScrolling;\n\n          if (force) {\n            scroll.y = currentY;\n            killScrub(mainST);\n          }\n\n          render(scroll.y, force);\n          updateVelocity();\n          _onUpdate && !paused && _onUpdate(_this);\n        }\n      }),\n      onRefreshInit: function onRefreshInit() {\n        recordedRefreshScroll = currentY;\n        scroll.y = wrapper.scrollTop = 0; // set wrapper.scrollTop to 0 because in some very rare situations, the browser will auto-set that, like if there's a hash in the link or changing focus to an off-screen input\n      },\n      id: \"ScrollSmoother\",\n      scroller: _win,\n      invalidateOnRefresh: true,\n      start: 0,\n      refreshPriority: -9999,\n      // because all other pins, etc. should be calculated first before this figures out the height of the body. BUT this should also update FIRST so that the scroll position on the proxy is up-to-date when all the ScrollTriggers calculate their progress! -9999 is a special number that ScrollTrigger looks for to handle in this way.\n      end: refreshHeight,\n      onScrubComplete: function onScrubComplete() {\n        tracker.reset();\n        onStop && onStop(_this);\n      },\n      scrub: smoothDuration || true,\n      onRefresh: function onRefresh(self) {\n        killScrub(self);\n        scroll.y = -scrollFunc();\n        render(scroll.y);\n        startupPhase || self.animation.progress(gsap.utils.clamp(0, 1, recordedRefreshScroll / -self.end));\n      }\n    });\n\n    this.smooth = function (value) {\n      smoothDuration = value;\n      return arguments.length ? mainST.scrubDuration(value) : mainST.getTween() ? mainST.getTween().duration() : 0;\n    };\n\n    mainST.getTween() && (mainST.getTween().vars.ease = vars.ease || _expo);\n    this.scrollTrigger = mainST;\n    vars.effects && this.effects(vars.effects === true ? \"[data-speed], [data-lag]\" : vars.effects, {});\n    vars.sections && this.sections(vars.sections === true ? \"[data-section]\" : vars.sections);\n    existingScrollTriggers.forEach(function (st) {\n      st.vars.scroller = wrapper;\n      st.init(st.vars, st.animation);\n    });\n\n    this.paused = function (value, allowNestedScroll) {\n      if (arguments.length) {\n        if (!!paused !== value) {\n          if (value) {\n            // pause\n            mainST.getTween() && mainST.getTween().pause();\n            scrollFunc(-currentY);\n            tracker.reset();\n            pausedNormalizer = ScrollTrigger.normalizeScroll();\n            pausedNormalizer && pausedNormalizer.disable(); // otherwise the normalizer would try to scroll the page on things like wheel events.\n\n            paused = ScrollTrigger.observe({\n              preventDefault: true,\n              type: \"wheel,touch,scroll\",\n              debounce: false,\n              allowClicks: true,\n              onChangeY: function onChangeY() {\n                return scrollTop(-currentY);\n              } // refuse to scroll\n\n            });\n            paused.nested = _inputObserver(_docEl, \"wheel,touch,scroll\", true, allowNestedScroll !== false); // allow nested scrolling, like modals\n          } else {\n            // resume\n            paused.nested.kill();\n            paused.kill();\n            paused = 0;\n            pausedNormalizer && pausedNormalizer.enable();\n            mainST.progress = (-currentY - mainST.start) / (mainST.end - mainST.start);\n            killScrub(mainST);\n          }\n        }\n\n        return this;\n      }\n\n      return !!paused;\n    };\n\n    this.kill = function () {\n      _this.paused(false);\n\n      killScrub(mainST);\n      mainST.kill();\n      var triggers = (effects || []).concat(sections || []),\n          i = triggers.length;\n\n      while (i--) {\n        // make sure we go backwards because the onKill() will effects.splice(index, 1) and we don't want to skip\n        triggers[i].kill();\n      }\n\n      ScrollTrigger.scrollerProxy(wrapper);\n      ScrollTrigger.removeEventListener(\"refresh\", onRefresh);\n\n      _body.style.removeProperty(\"height\");\n\n      wrapper.style.cssText = wrapperCSS;\n      content.style.cssText = contentCSS;\n      var defaults = ScrollTrigger.defaults({});\n      defaults && defaults.scroller === wrapper && ScrollTrigger.defaults({\n        scroller: _win\n      });\n      _this.normalizer && ScrollTrigger.normalizeScroll(false);\n      clearInterval(intervalID);\n      _mainInstance = null;\n\n      _win.removeEventListener(\"focusin\", _onFocusIn);\n    };\n\n    this.refresh = function (soft, force) {\n      return mainST.refresh(soft, force);\n    };\n\n    if (normalizeScroll) {\n      this.normalizer = ScrollTrigger.normalizeScroll(normalizeScroll === true ? {\n        debounce: true,\n        content: content\n      } : normalizeScroll);\n    }\n\n    ScrollTrigger.config(vars); // in case user passes in ignoreMobileResize for example\n\n    \"overscrollBehavior\" in _win.getComputedStyle(_body) && gsap.set([_body, _docEl], {\n      overscrollBehavior: \"none\"\n    });\n    \"scrollBehavior\" in _win.getComputedStyle(_body) && gsap.set([_body, _docEl], {\n      scrollBehavior: \"auto\"\n    }); // if the user hits the tab key (or whatever) to shift focus to an element that's off-screen, center that element.\n\n    _win.addEventListener(\"focusin\", _onFocusIn);\n\n    intervalID = setInterval(updateVelocity, 250);\n    _doc.readyState === \"loading\" || requestAnimationFrame(function () {\n      return ScrollTrigger.refresh();\n    });\n  }\n\n  ScrollSmoother.register = function register(core) {\n    if (!_coreInitted) {\n      gsap = core || _getGSAP();\n\n      if (_windowExists() && window.document) {\n        _win = window;\n        _doc = document;\n        _docEl = _doc.documentElement;\n        _body = _doc.body;\n      }\n\n      if (gsap) {\n        _toArray = gsap.utils.toArray;\n        _clamp = gsap.utils.clamp;\n        _expo = gsap.parseEase(\"expo\");\n        ScrollTrigger = gsap.core.globals().ScrollTrigger;\n        gsap.core.globals(\"ScrollSmoother\", ScrollSmoother); // must register the global manually because in Internet Explorer, functions (classes) don't have a \"name\" property.\n        //\tgsap.ticker.lagSmoothing(50, 100); // generally people don't want things to jump (honoring smoothness over time is better with smooth scrolling)\n\n        if (_body && ScrollTrigger) {\n          _root = [_win, _doc, _docEl, _body];\n          _getVelocityProp = ScrollTrigger.core._getVelocityProp;\n          _inputObserver = ScrollTrigger.core._inputObserver;\n          ScrollSmoother.refresh = ScrollTrigger.refresh;\n          _coreInitted = 1;\n        }\n      }\n    }\n\n    return _coreInitted;\n  };\n\n  _createClass(ScrollSmoother, [{\n    key: \"progress\",\n    get: function get() {\n      return this.scrollTrigger.animation._time / 100;\n    }\n  }]);\n\n  return ScrollSmoother;\n}();\nScrollSmoother.version = \"3.10.4\";\n\nScrollSmoother.create = function (vars) {\n  return _mainInstance && vars && _mainInstance.content() === _toArray(vars.content)[0] ? _mainInstance : new ScrollSmoother(vars);\n};\n\nScrollSmoother.get = function () {\n  return _mainInstance;\n};\n\n_getGSAP() && gsap.registerPlugin(ScrollSmoother);\nexport { ScrollSmoother as default };"],
  "mappings": "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",
  "names": ["_windowExists", "_getGSAP", "_round", "_autoDistance", "_wrap", "ScrollSmoother", "updateVelocity", "removeScroll", "killScrub", "render", "scrollTop", "_onFocusIn", "adjustParallaxPosition", "onRefresh", "restoreEffects", "revertEffects", "effectValueGetter", "createEffect", "initDynamicValues", "revert", "updateChange", "smooth", "i"]
}
